#!/bin/sh

[ -f /jffs/dnscrypt/.config ] && . /jffs/dnscrypt/.config

NAME="$(basename "$0")[$$]"

append_on_demand () {
  local TARGET
  local LINE
  TARGET="$1"
  shift
  for LINE in "$@"; do
    if ! grep -qF "$LINE" "$TARGET"; then
      printf "%s\n" "$LINE" >> "$TARGET"
    fi
  done
}

check_dns_environment () {
  local NVCHECK
  NVCHECK="0"
  if [ "$(nvram get dnspriv_enable)" != "0" ]; then { nvram set dnspriv_enable="0"; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$(pidof stubby)" ]; then { killall -q -9 stubby 2>/dev/null; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$(nvram get dhcp_dns1_x)" ] && [ "$NVCHECK" != "0" ]; then { nvram set dhcp_dns1_x=""; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$(nvram get dhcp_dns2_x)" ] && [ "$NVCHECK" != "0" ]; then { nvram set dhcp_dns2_x=""; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$(nvram get dhcpd_dns_router)" != "1" ] && [ "$NVCHECK" != "0" ]; then { nvram set dhcpd_dns_router="1"; }; NVCHECK="$((NVCHECK+1))"; fi
  if [ "$NVCHECK" != "0" ]; then { nvram commit; }; { service restart_dnsmasq >/dev/null 2>&1; }; while { ! netcheck; }; do sleep 1; done; fi
}

dnscrypt_proxy_run () {
  local lock_dir
  local pid_file
  lock_dir="/tmp/dnscrypt-proxy"
  pid_file="${lock_dir}/pid"
  if ( mkdir ${lock_dir} ) 2> /dev/null; then
    printf "%s\n" "$$" > $pid_file
    trap 'rm -rf /tmp/dnscrypt-proxy; exit $?' EXIT
    start="$(date +%s)"
    $1
    end="$(date +%s)"
    runtime="$((end-start))"
    logger -st "$NAME" "$1 took $runtime second(s) to complete."
    rm -rf "$lock_dir"
  else
    logger -st "$NAME" "Lock owned by $(cat $pid_file) exists; preventing duplicate runs!"
  fi
}

dnsmasq_params () {
  local DNS
  local VAR
  if { [ "$(nvram get dns_local_cache)" != "1" ] && [ "$(readlink -f /tmp/resolv.conf)" = "/rom/etc/resolv.conf" ]; }; then { umount /tmp/resolv.conf 2>/dev/null; }; fi
  if [ -n "$(pidof dnscrypt-proxy)" ]; then
    cp -a /tmp/resolv.dnsmasq /jffs/dnscrypt/resolv.dnsmasq
    append_on_demand /etc/dnsmasq.conf "no-resolv"
    append_on_demand /jffs/dnscrypt/resolv.dnsmasq "server=127.0.1.1"
    for DNS in $(nvram get wan_dns) $(nvram get wan0_dns) $(nvram get wan1_dns) $(nvram get wan_dns1_x) $(nvram get wan_dns2_x) $(nvram get wan0_dns1_x) $(nvram get wan0_dns2_x) $(nvram get wan1_dns1_x) $(nvram get wan1_dns2_x) $(nvram get wan0_xdns) $(nvram get wan1_xdns) $(nvram get ipv6_get_dns); do
      sed -i "/^server=$DNS.*$/d" /jffs/dnscrypt/resolv.dnsmasq
    done
    for VAR in 1 2 3; do
      DNS="$(nvram get "ipv6_dns$VAR")"
      [ -n "$DNS" ] && sed -i "/^server=$DNS.*$/d" /jffs/dnscrypt/resolv.dnsmasq
    done
    sed -i "/^servers-file=.*$/d" /etc/dnsmasq.conf
    append_on_demand /etc/dnsmasq.conf "servers-file=/jffs/dnscrypt/resolv.dnsmasq"
    if { [ "$(nvram get dns_local_cache)" != "1" ] && [ "$DNSCRYPT_LOCAL" = "YES" ]; }; then { mount -o bind /rom/etc/resolv.conf /tmp/resolv.conf; }; fi
  fi
}

init_hwrng () {
  local COUNT
  COUNT="0"
  while [ ! -c "$RNG_DEV" ]; do
    if [ "$COUNT" -gt 120 ]; then
      logger -st "$NAME" "ERROR: Unable to find HWRNG device. Aborting..."
      if [ -f "/jffs/dnscrypt/haveged" ]; then { /jffs/dnscrypt/haveged -w 1024 -d 32 -i 32 -v 1; }; logger -st "$NAME" "Haveged: Using available haveged instead..."; fi
      exit 1
    fi
    COUNT="$((COUNT+1))"
    sleep 1
  done
  { /jffs/dnscrypt/stty raw -echo -ixoff -F "$RNG_DEV" speed 115200; };
  { /jffs/dnscrypt/rngd -r "$RNG_DEV"; };
  [ $? -eq 0 ] && logger -st "$NAME" "rngd: Started for $RNG_DEV"
}

proc_optimizations () {
  { printf "2" > /proc/sys/vm/overcommit_memory; }; # Ensure ratio algorithm checks properly work including swap.
  { printf "2500000" > /proc/sys/net/core/rmem_max; }; # Ensure UDP receive buffer set to 2.5M.
  { printf "0" > /proc/sys/net/ipv4/icmp_ratelimit; }; # Ensure Control over MTRS
  { printf "256" > /proc/sys/net/ipv4/neigh/default/gc_thresh1; }; # Increase ARP cache sizes and GC thresholds
  { printf "1024" > /proc/sys/net/ipv4/neigh/default/gc_thresh2; }; # Increase ARP cache sizes and GC thresholds
  { printf "2048" > /proc/sys/net/ipv4/neigh/default/gc_thresh3; }; # Increase ARP cache sizes and GC thresholds
  { printf "240" > /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_max_retrans; }; # Lower conntrack tcp_timeout_max_retrans from 300 to 240
  if [ -n "$(nvram get ipv6_service)" ]; then #IPV6 proc variants
    { printf "0" > /proc/sys/net/ipv6/icmp/ratelimit; };
    { printf "256" > /proc/sys/net/ipv6/neigh/default/gc_thresh1; };
    { printf "1024" > /proc/sys/net/ipv6/neigh/default/gc_thresh2; };
    { printf "2048" > /proc/sys/net/ipv6/neigh/default/gc_thresh3; };
  fi
}

netcheck() {
  local ALIVE
  if { [ "$(/bin/date +"%Y")" -gt "1970" ] || [ "$(nvram get ntp_ready)" -ne "0" ]; }; then ALIVE="0"; else ALIVE="1"; fi
  if { [ "$(ping 1.1.1.1 -c1 -W2 >/dev/null 2>&1; printf "%s" "$?")" = "0" ] && [ "$(nslookup google.com 127.0.0.1 >/dev/null 2>&1; printf "%s" "$?")" = "0" ]; }; then ALIVE="0"; else ALIVE="$((ALIVE+1))"; fi
  if { [ "$(curl -Is  http://www.google.com | head -n 1 >/dev/null 2>&1; printf "%s" "$?")" = "0" ] || [ "$(wget -q --spider http://google.com >/dev/null 2>&1; printf "%s" "$?")" = "0" ]; }; then ALIVE="0"; else ALIVE="$((ALIVE+1))"; fi
  if [ "$ALIVE" -ne "0" ]; then return 1; else return 0; fi
}

start_dnscrypt_proxy () {
  local COUNTER
  local LIMIT
  local STATE
  local NW_STATE
  local RES_STATE
  local DNSCRYPT_START
  { cd /jffs/dnscrypt; } || exit
  { killall -s 9 "$(pidof dnscrypt-proxy)" 2>/dev/null || killall -q -9 dnscrypt-proxy 2>/dev/null; };
  DNSCRYPT_START="/jffs/dnscrypt/dnscrypt-proxy -syslog -config /jffs/dnscrypt/dnscrypt-proxy.toml"
  logger -st "$NAME" "Starting dnscrypt-proxy from $NAME."
  { nohup $DNSCRYPT_START >/dev/null 2>&1 </dev/null & };
  COUNTER="0";
  LIMIT="10";
  { while [ -z "$(pidof dnscrypt-proxy)" ] && [ "$COUNTER" -le "$LIMIT" ]; do sleep 1; COUNTER="$((COUNTER + 1))"; done; };
  if ! grep -qF "servers-file=/jffs/dnscrypt/resolv.dnsmasq" "/etc/dnsmasq.conf"; then { service restart_dnsmasq >/dev/null 2>&1; }; fi
  STATE="0"
  [ -z "$1" ] && while { ! netcheck; }; do sleep 1; done
  [ "$STATE" -eq "10" ] && start_dnscrypt_proxy x
}

stop_dnscrypt_proxy () {
  local COUNTER
  local LIMIT
  { cd /jffs/dnscrypt; } || exit
  logger -st "$NAME" "Stopping dnscrypt-proxy from $NAME."
  { killall -s 9 "$(pidof dnscrypt-proxy)" 2>/dev/null || killall -q -9 dnscrypt-proxy 2>/dev/null; };
  COUNTER="0";
  LIMIT="10";
  { while [ -n "$(pidof dnscrypt-proxy)" ] && [ "$COUNTER" -le "$LIMIT" ]; do sleep 1; COUNTER="$((COUNTER + 1))"; done; };
  if grep -qF "servers-file=/jffs/dnscrypt/resolv.dnsmasq" "/etc/dnsmasq.conf"; then { service restart_dnsmasq >/dev/null 2>&1; }; fi
}

start_monitor () {
  trap '' HUP INT QUIT ABRT TERM
  trap 'EXIT="1"' USR1
  trap 'EXIT="2"' USR2
  while { ! netcheck; }; do sleep 1; done
  local COUNT
  local EXIT
  local RANDOM
  EXIT="0"
  RANDOM="0"
  logger -st "$NAME" "Starting Monitor!"
  while true; do
    if [ -f "/jffs/dnscrypt/dnscrypt-proxy" ]; then
      if [ -z "$COUNT" ]; then COUNT="0"; timezone; "$0" opendns-update; { dnscrypt_proxy_run start_dnscrypt_proxy; }; fi
      case $EXIT in
        "0")
          case $COUNT in
            "30"|"60"|"90")
              timezone;
              "$0" opendns-update;
              if { ! netcheck && [ -n "$(pidof dnscrypt-proxy)" ]; }; then logger -st "$NAME" "Warning: dnscrypt-proxy is not responding; Monitor will re-start it!"; unset COUNT; fi;
              if [ "$COUNT" = "90" ]; then COUNT="0"; else COUNT="$((COUNT + 1))"; fi;
              ;;
             *)
              COUNT="$((COUNT + 1))";
              ;;
          esac
          if [ -z "$(pidof "$PROCS")" ]; then logger -st "$NAME" "Warning: dnscrypt-proxy is dead; Monitor will start it!"; unset COUNT; fi;
          case $RANDOM in
            "4320")
              RANDOM="0";
              logger -st "$NAME" "Randomization: Health Check; Monitor will randomize it!";
              unset COUNT;
              ;;
             *)
              RANDOM="$((RANDOM + 1))";
              ;;
          esac
          ;;
        "1")
          logger -st "$NAME" "Stopping Monitor!";
          trap - HUP INT QUIT ABRT USR1 USR2 TERM;
          { dnscrypt_proxy_run stop_dnscrypt_proxy; };
          break;
          ;;
        "2")
          logger -st "$NAME" "Monitor is restarting dnscrypt-proxy!";
          unset COUNT;
          EXIT="0";
          ;;
      esac    
    fi
    if [ -z "$COUNT" ]; then sleep 1; else sleep 10; fi
  done
}

stop_monitor () {
  local SIGNAL
  case "$1" in
    "$MON_PID")
      SIGNAL="12"
      ;;
    "$$")
      if [ -n "$MON_PID" ]; then SIGNAL="10"; else { dnscrypt_proxy_run stop_dnscrypt_proxy; }; fi
      ;;
  esac
  [ -n "$SIGNAL" ] && { kill -s "$SIGNAL" "$MON_PID" 2>/dev/null; };
}

timezone () {
  local TIMEZONE
  local TARGET
  TIMEZONE="/jffs/dnscrypt/localtime"
  TARGET="/etc/localtime"
  if { [ ! -f "$TARGET" ] && [ -f "$TIMEZONE" ]; }; then { ln -sf "$TIMEZONE" "$TARGET"; }; fi
  if [ -f "$TARGET" ] || [ "$(readlink "$TARGET")" ]; then { if [ "$(date -u '+%s')" -le "$(date -u -r "$0" '+%s')" ]; then { date -u -s "$(date -u -r "$0" '+%Y-%m-%d %H:%M:%S')"; }; else { touch "$0"; }; fi; }; fi
}

update_opendns () {
  if [ -z "$OPENDNS_USER" ] || [ -z  "$OPENDNS_PASSWORD" ] || [ "$1" -gt 2 ]; then
    return
  fi
  sleep 5
  RET="$(curl -k -s -u "$OPENDNS_USER:$OPENDNS_PASSWORD" "https://updates.opendns.com/nic/update?hostname=")"
  case "$RET" in
    good*)
      logger -st "$NAME" "OpenDNS: Update IP succeeded"
      ;;
    badauth*)
      logger -st "$NAME" "OpenDNS: Wrong username or password"
      ;;
    *)
      logger -st "$NAME" "OpenDNS: Received error $RET"
      update_opendns "$(($1+1))"
      ;;
  esac
}

{ for PID in $(pidof "$(basename "$0")"); do if { awk '{ print }' "/proc/${PID}/cmdline" | grep -q monitor-start; } && [ "$PID" != "$$" ]; then { MON_PID="$PID"; }; fi; done; };

unset TZ
case "$1" in
  "dnsmasq")
    dnsmasq_params
    ;;
  "start"|"restart"|"dnscrypt-start")
    { "$0" init-start >/dev/null 2>&1; };
    ;;
  "stop"|"kill"|"dnscrypt-stop")
    { "$0" services-stop >/dev/null 2>&1; };
    ;;
  "monitor-start")
    if [ -n "$MON_PID" ]; then { stop_monitor "$MON_PID"; }; else { start_monitor & }; fi
    ;;
  "opendns-update")
    update_opendns 0 &
    ;;
  "init-start"|"services-stop")
    timezone
    if [ -n "$RAN_PRV" ]; then { kill -s 9 "$(pidof haveged jitterentropy-rngd rngd stty)" 2>/dev/null || killall -q -9 haveged jitterentropy-rngd rngd stty 2>/dev/null; }; fi
    case "$1" in
      "init-start")
        proc_optimizations
        case "$RAN_PRV" in
          "haveged")
            { /jffs/dnscrypt/haveged -w 1024 -d 32 -i 32 -v 1; };
            ;;
          "rngd")
            init_hwrng &
            ;;
        esac
        { "$0" monitor-start; };
        ;;
      "services-stop")
        { stop_monitor "$$"; };
        ;;
    esac
    ;;
esac
check_dns_environment
